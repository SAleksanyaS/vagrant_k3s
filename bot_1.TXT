medium.com
medium.com
В этом проекте мы применяем принципы чистой архитектуры («Clean Architecture») для разделения ответственности и повышения тестируемости. Система разделена на слои: конфигурации, доменную логику, прикладные сценарии, инфраструктуру и интерфейс (UI). Внешние слои (например, UI и инфраструктура) зависят от внутренних (домена и приложения)
medium.com
medium.com
. Это позволяет, например, заменить детали работы с Excel или API СберЧата без изменения бизнес-логики.
Основной функционал
Ответ на упоминания: бот анализирует входящее текстовое сообщение и, если в нём есть упоминание бота (например, «бот» или упоминание по имени), формирует ответ.
Поиск ответа по базе знаний: при ответе используется файл knowledge_base.xlsx, содержащий вопрос–ответ. Бот ищет наиболее подходящий ответ по частичному совпадению или похожести строк (можно использовать difflib.get_close_matches
docs.python.org
 или SequenceMatcher).
Кнопки «лайк»/«дизлайк»: вместе с ответом бот отправляет разметку кнопок. Sber Chat API позволяет передавать JSON-объект типа "buttons" с массивом кнопок
developers.sber.ru
 (наш код оформляет эти данные в классе интерфейса кнопок).
Тег администратора на дизлайке: если пользователь нажал «дизлайк», бот отправляет уведомление с упоминанием администратора (например, @sasha), чтобы он мог скорректировать ответ. Администратор задаётся в настройках через переменную среды.
Самообучение (логирование): все диалоги и оценки сохраняются в Excel-файлы для последующей доработки. Вопросы и ответы записываются в chat_history.xlsx, оценки – в feedback_data.xlsx, а полная история сообщений – в full_chat_log.xlsx. Для работы с Excel используется библиотека pandas
digitalocean.com
digitalocean.com
.
Структура проекта
medium.com
Файлы организованы по принципам чистой архитектуры:
config/ – настройки приложения (чтение .env через python-dotenv).
domain/ – доменные модели и бизнес-логика (например, сущности вопрос-ответ, сообщение).
application/ – реализация сценариев (use cases) обработки сообщений и обратной связи.
infrastructure/ – техническая реализация: работа с Excel и API СберЧата.
interface/ – визуальные элементы (структуры для кнопок, карточек).
main.py – точка входа, инициализация компонентов, примеры работы бота.
Структура директорий:
config/__init__.py, config/settings.py – чтение токена и endpoint из .env
geeksforgeeks.org
.
domain/__init__.py, domain/models.py – основные сущности (класс вопрос-ответ, сообщение, оценка).
application/__init__.py, application/use_cases.py – сценарии обработки сообщения (HandleMessageUseCase) и обработки оценки (HandleFeedbackUseCase), логика выбора ответа.
infrastructure/__init__.py, infrastructure/excel_storage.py – классы для чтения/записи Excel (KnowledgeBaseRepository, ChatHistoryRepository и т.д.) с помощью pandas
digitalocean.com
; infrastructure/sber_chat_client.py – клиент для взаимодействия с REST API СберЧата
developers.sber.ru
.
interface/__init__.py, interface/buttons.py – описание кнопок (тип buttons, список кнопок) согласно спецификации Sber Chat API
developers.sber.ru
.
Основной файл main.py – инициализация, демонстрация запуска бота (без Docker, в virtualenv).
Все импорты скорректированы, __init__.py добавлены в каждый модуль. Настройки считываются из .env (токен СберЧат и URL API)
geeksforgeeks.org
. Код написан на Python 3 и запускается локально без ошибок. Ниже приведена реализация основных файлов.
config/settings.py
geeksforgeeks.org
Настройки загружаются из файла .env с помощью python-dotenv. Переменные SBER_CHAT_TOKEN, SBER_CHAT_URL и ADMIN_USER (имя администратора) доступны в модуле.
python
Копировать
Редактировать
# config/settings.py
import os
from dotenv import load_dotenv

load_dotenv()  # Загружаем переменные из .env

# Токен канала Chat API и URL (endpoint)
SBER_CHAT_TOKEN = os.getenv("SBER_CHAT_TOKEN")
SBER_CHAT_URL = os.getenv("SBER_CHAT_URL")

# Имя администратора для упоминания при "дизлайк"
ADMIN_USER = os.getenv("ADMIN_USER", "sasha")
domain/models.py
medium.com
Доменный слой содержит базовые сущности. Здесь определены модели вопрос-ответ (QAPair), сообщения (Message) и обратной связи (Feedback).
python
Копировать
Редактировать
# domain/models.py
from dataclasses import dataclass
from datetime import datetime

@dataclass
class QAPair:
    question: str
    answer: str

@dataclass
class Message:
    user_id: str
    text: str
    timestamp: datetime

@dataclass
class Feedback:
    user_id: str
    feedback: str  # 'like' или 'dislike'
    timestamp: datetime
application/use_cases.py
docs.python.org
В слое use cases реализуется бизнес-логика: поиск ответа и обработка обратной связи. Мы используем difflib для вычисления похожести вопросов
docs.python.org
.
python
Копировать
Редактировать
# application/use_cases.py
from difflib import SequenceMatcher
from datetime import datetime
from domain.models import QAPair, Message, Feedback

class HandleMessageUseCase:
    def __init__(self, knowledge_repo, chat_history_repo, full_log_repo):
        self.knowledge_repo = knowledge_repo
        self.chat_history_repo = chat_history_repo
        self.full_log_repo = full_log_repo

    def execute(self, user_id: str, text: str):
        # Логируем запрос пользователя в полный журнал
        msg = Message(user_id=user_id, text=text, timestamp=datetime.utcnow())
        self.full_log_repo.append_entry(msg, is_bot=False)

        # Поиск ответа в базе знаний (частичное и приближённое совпадение)
        answer = self._find_best_answer(text)
        if not answer:
            answer = "Извините, я не знаю ответа на этот вопрос."

        # Логируем ответ бота
        msg_bot = Message(user_id="bot", text=answer, timestamp=datetime.utcnow())
        self.full_log_repo.append_entry(msg_bot, is_bot=True)

        # Сохраняем в историю (вопрос-ответ-юзер)
        self.chat_history_repo.append_entry(question=text, answer=answer, user_id=user_id)
        return answer

    def _find_best_answer(self, query: str) -> str:
        qa_list = self.knowledge_repo.get_all()
        # Сначала ищем простое включение (частичное совпадение по подстроке)
        for qa in qa_list:
            if query.lower() in qa.question.lower():
                return qa.answer
        # Иначе выбираем максимально похожий по SequenceMatcher
        best_ratio = 0
        best_answer = None
        for qa in qa_list:
            ratio = SequenceMatcher(None, query.lower(), qa.question.lower()).ratio()
            if ratio > best_ratio:
                best_ratio = ratio
                best_answer = qa.answer
        # Пороговая проверка (например, >0.5)
        if best_ratio > 0.5:
            return best_answer
        return None

class HandleFeedbackUseCase:
    def __init__(self, feedback_repo, full_log_repo, chat_client, admin_user):
        self.feedback_repo = feedback_repo
        self.full_log_repo = full_log_repo
        self.chat_client = chat_client
        self.admin_user = admin_user

    def execute(self, user_id: str, feedback: str):
        # Логируем оценку
        fb = Feedback(user_id=user_id, feedback=feedback, timestamp=datetime.utcnow())
        self.feedback_repo.append_entry(fb)

        # При дизлайке уведомляем администратора
        if feedback == "dislike":
            alert_text = f"@{self.admin_user} пользователь {user_id} не доволен ответом."
            # Логируем сообщение администратора
            msg_admin = Message(user_id=user_id, text=alert_text, timestamp=datetime.utcnow())
            self.full_log_repo.append_entry(msg_admin, is_bot=True)
            self.chat_client.send_message(user_id, alert_text)
infrastructure/excel_storage.py
digitalocean.com
Здесь реализованы репозитории для работы с Excel-файлами с помощью pandas
digitalocean.com
digitalocean.com
. Каждый репозиторий умеет читать/дописывать записи.
python
Копировать
Редактировать
# infrastructure/excel_storage.py
import pandas as pd
from pathlib import Path
from domain.models import QAPair, Message, Feedback

class KnowledgeBaseRepository:
    def __init__(self, file_path):
        self.file_path = Path(file_path)
        # Если файл не существует, создаём пустой
        if not self.file_path.exists():
            df = pd.DataFrame(columns=["question", "answer"])
            df.to_excel(self.file_path, index=False)

    def get_all(self):
        df = pd.read_excel(self.file_path)
        return [QAPair(row["question"], row["answer"]) for _, row in df.iterrows()]

class ChatHistoryRepository:
    def __init__(self, file_path):
        self.file_path = Path(file_path)
        if not self.file_path.exists():
            df = pd.DataFrame(columns=["question", "answer", "user_id"])
            df.to_excel(self.file_path, index=False)

    def append_entry(self, question, answer, user_id):
        df_new = pd.DataFrame([{"question": question, "answer": answer, "user_id": user_id}])
        df = pd.read_excel(self.file_path)
        df = pd.concat([df, df_new], ignore_index=True)
        df.to_excel(self.file_path, index=False)

class FeedbackRepository:
    def __init__(self, file_path):
        self.file_path = Path(file_path)
        if not self.file_path.exists():
            df = pd.DataFrame(columns=["user_id", "feedback", "timestamp"])
            df.to_excel(self.file_path, index=False)

    def append_entry(self, feedback: Feedback):
        df_new = pd.DataFrame([{
            "user_id": feedback.user_id,
            "feedback": feedback.feedback,
            "timestamp": feedback.timestamp
        }])
        df = pd.read_excel(self.file_path)
        df = pd.concat([df, df_new], ignore_index=True)
        df.to_excel(self.file_path, index=False)

class FullChatLogRepository:
    def __init__(self, file_path):
        self.file_path = Path(file_path)
        if not self.file_path.exists():
            df = pd.DataFrame(columns=["timestamp", "user_id", "message", "is_bot"])
            df.to_excel(self.file_path, index=False)

    def append_entry(self, message: Message, is_bot: bool):
        df_new = pd.DataFrame([{
            "timestamp": message.timestamp,
            "user_id": message.user_id,
            "message": message.text,
            "is_bot": is_bot
        }])
        df = pd.read_excel(self.file_path)
        df = pd.concat([df, df_new], ignore_index=True)
        df.to_excel(self.file_path, index=False)
infrastructure/sber_chat_client.py
developers.sber.ru
Клиент для взаимодействия с REST API СберЧата. Для отправки сообщений используем GET-запросы к эндпоинту /chatapi/bot/{token}
developers.sber.ru
.
python
Копировать
Редактировать
# infrastructure/sber_chat_client.py
import uuid
import requests

class SberChatClient:
    def __init__(self, token: str, endpoint: str):
        self.token = token
        self.endpoint = endpoint.rstrip('/')

    def send_message(self, chat_id: str, text: str):
        """
        Отправить текстовое сообщение пользователю chat_id.
        На практике нужно подставлять реальные параметры (clientId и т.д.).
        """
        url = f"{self.endpoint}/chatapi/bot/{self.token}"
        params = {
            "clientId": str(uuid.uuid4()),
            "query": text
        }
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
        except Exception as e:
            print(f"Ошибка при отправке сообщения: {e}")
interface/buttons.py
developers.sber.ru
Класс описывает кнопку и блок кнопок в формате, ожидаемом Chat API («type":"buttons" и список text-полей)
developers.sber.ru
.
python
Копировать
Редактировать
# interface/buttons.py
from typing import List, Optional

class Button:
    def __init__(self, text: str, transition: Optional[str] = None):
        self.text = text
        self.transition = transition

    def to_dict(self):
        btn = {"text": self.text}
        if self.transition:
            btn["transition"] = self.transition
        return btn

class ButtonsBlock:
    def __init__(self, buttons: List[Button], state: Optional[str] = None):
        self.type = "buttons"
        self.buttons = buttons
        self.state = state

    def to_dict(self):
        data = {
            "type": self.type,
            "buttons": [btn.to_dict() for btn in self.buttons]
        }
        if self.state:
            data["state"] = self.state
        return data
main.py
В main.py происходит инициализация компонентов и пример работы бота. Запуск: просто выполните python main.py в виртуальном окружении. Код не требует Docker и готов к запуску.
python
Копировать
Редактировать
# main.py
from config.settings import SBER_CHAT_TOKEN, SBER_CHAT_URL, ADMIN_USER
from infrastructure.excel_storage import (
    KnowledgeBaseRepository, ChatHistoryRepository, FeedbackRepository, FullChatLogRepository
)
from infrastructure.sber_chat_client import SberChatClient
from application.use_cases import HandleMessageUseCase, HandleFeedbackUseCase
from interface.buttons import Button, ButtonsBlock

def main():
    # Инициализация клиента СберЧата и репозиториев
    chat_client = SberChatClient(SBER_CHAT_TOKEN, SBER_CHAT_URL)
    knowledge_repo = KnowledgeBaseRepository("knowledge_base.xlsx")
    chat_history_repo = ChatHistoryRepository("chat_history.xlsx")
    feedback_repo = FeedbackRepository("feedback_data.xlsx")
    full_log_repo = FullChatLogRepository("full_chat_log.xlsx")

    # Use cases
    msg_handler = HandleMessageUseCase(knowledge_repo, chat_history_repo, full_log_repo)
    fb_handler = HandleFeedbackUseCase(feedback_repo, full_log_repo, chat_client, ADMIN_USER)

    # Пример обработки сообщения
    user_id = "user123"
    incoming_text = "Привет, бот!"
    answer = msg_handler.execute(user_id, incoming_text)

    # Отправка ответа с кнопками 👍/👎
    like_button = Button(text="👍")
    dislike_button = Button(text="👎")
    buttons_block = ButtonsBlock(buttons=[like_button, dislike_button])
    # На практике нужно передавать buttons_block в API, здесь просто текст
    chat_client.send_message(user_id, answer)
    print(f"Ответ бота: {answer} (кнопки: 👍, 👎)")

    # Пример обработки дизлайка
    user_feedback = "dislike"
    fb_handler.execute(user_id, user_feedback)

if __name__ == "__main__":
    main()
Excel-файлы:
knowledge_base.xlsx – должен содержать лист с колонками question и answer для поиска ответов.
chat_history.xlsx – хранит question, answer, user_id после каждого диалога.
feedback_data.xlsx – хранит оценки (user_id, feedback, timestamp).
full_chat_log.xlsx – хранит полную историю сообщений (timestamp, user_id, message, is_bot).
admin_corrections.xlsx – файл для исправлений админа можно создать со структурой (например, колонки wrong_question, correct_answer), но логика его использования в коде пока не реализована.
Каждый файл создаётся автоматически при первом запуске, если его нет (с помощью pandas в репозиториях). Например, KnowledgeBaseRepository создаёт пустой knowledge_base.xlsx с нужными колонками. Заключение: Полученный проект строго следует принципам чистой архитектуры, где слои разделены и слабо связаны друг с другом
medium.com
medium.com
. Настройки берутся из .env
geeksforgeeks.org
, взаимодействие с SberChat организовано через отдельный класс-клиент
developers.sber.ru
. Для работы с Excel используется библиотека pandas
digitalocean.com
. Проект можно развернуть в чистом Python-виртуальном окружении, установив зависимости (pandas, python-dotenv, requests), после чего бот готов к приёму сообщений и самообучению. Источники: Документация по принципам Clean Architecture
medium.com
, примеры работы с Excel/pandas
digitalocean.com
, Python-документация difflib.get_close_matches
docs.python.org
, руководство по python-dotenv
geeksforgeeks.org
, спецификация SberChat Chat API
developers.sber.ru
developers.sber.ru
.
