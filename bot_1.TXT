1. main.py
from interface.chat_bot import SberChatBotApp
from infrastructure.logger import setup_logger
import config
import logging

def main():
    setup_logger()
    logging.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")

    bot_app = SberChatBotApp(token=config.SBER_TOKEN)
    bot_app.run()

if __name__ == "__main__":
    main()


2. config.py
SBER_TOKEN = "–≤–∞—à_—Ç–æ–∫–µ–Ω_—Å—é–¥–∞"
KNOWLEDGE_PATH = "data/knowledge.xlsx"
HISTORY_PATH = "data/history.xlsx"
LOG_PATH = "logs/bot.log"

3. requirements.txt
dialog-bot-sdk
pandas
openpyxl
rapidfuzz

4. core/entities.py
from dataclasses import dataclass

@dataclass
class QAPair:
    question: str
    answer: str

@dataclass
class ChatMessage:
    user_id: int
    message_text: str
    message_id: str

5. core/exceptions.py

class BotError(Exception):
    pass


6. application/bot_service.py

from typing import Optional
from core.entities import QAPair
from infrastructure.excel_repository import ExcelRepository
from infrastructure.fuzzy_search import fuzzy_search_best_match

class BotService:
    def __init__(self, knowledge_path: str, history_path: str):
        self.knowledge_repo = ExcelRepository(knowledge_path)
        self.history_repo = ExcelRepository(history_path)

    def get_best_answer(self, question: str) -> Optional[QAPair]:
        knowledge = self.knowledge_repo.read_all()
        best_match = fuzzy_search_best_match(question, knowledge)
        return best_match

    def log_message(self, user_id: int, text: str, message_id: str):
        self.history_repo.append_raw({"user_id": user_id, "text": text, "message_id": message_id})

7. infrastructure/excel_repository.py

import pandas as pd
from core.entities import QAPair

class ExcelRepository:
    def __init__(self, filepath: str):
        self.filepath = filepath
        self.columns = ['question', 'answer']

    def read_all(self) -> list[QAPair]:
        try:
            df = pd.read_excel(self.filepath)
            return [QAPair(row['question'], row['answer']) for _, row in df.iterrows()]
        except FileNotFoundError:
            return []

    def append(self, qa_pair: QAPair):
        try:
            df = pd.read_excel(self.filepath)
        except FileNotFoundError:
            df = pd.DataFrame(columns=self.columns)
        df = pd.concat([df, pd.DataFrame([{"question": qa_pair.question, "answer": qa_pair.answer}])], ignore_index=True)
        df.to_excel(self.filepath, index=False)

    def append_raw(self, data: dict):
        try:
            df = pd.read_excel(self.filepath)
        except FileNotFoundError:
            df = pd.DataFrame()
        df = pd.concat([df, pd.DataFrame([data])], ignore_index=True)
        df.to_excel(self.filepath, index=False)

8. infrastructure/fuzzy_search.py

from rapidfuzz import process
from core.entities import QAPair

def fuzzy_search_best_match(query: str, knowledge: list[QAPair]) -> QAPair | None:
    choices = [qa.question for qa in knowledge]
    if not choices:
        return None
    match = process.extractOne(query, choices, score_cutoff=60)
    if match:
        matched_question = match[0]
        for qa in knowledge:
            if qa.question == matched_question:
                return qa
    return None


9. infrastructure/logger.py
import logging
from config import LOG_PATH

def setup_logger():
    logging.basicConfig(
        filename=LOG_PATH,
        level=logging.INFO,
        format='%(asctime)s %(levelname)s %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
    )

10. interface/chat_bot.py

import logging
from dialog_bot_sdk import DialogBot
from application.bot_service import BotService
from interface.handlers import MessageHandler
from config import KNOWLEDGE_PATH, HISTORY_PATH

class SberChatBotApp:
    def __init__(self, token: str):
        self.bot = DialogBot(token)
        self.bot_service = BotService(KNOWLEDGE_PATH, HISTORY_PATH)
        self.handler = MessageHandler(self.bot, self.bot_service)

        self.bot.messaging.on_message(self.handler.on_message)
        self.bot.messaging.on_reaction(self.handler.on_reaction)  # <-- –¥–æ–±–∞–≤–ª–µ–Ω–æ

    def run(self):
        logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.")
        self.bot.run_forever()



11. interface/handlers.py

import logging
from dialog_bot_sdk.entities import Message
from dialog_bot_sdk.messaging import InteractiveMedia, InteractiveMediaGroup

class MessageHandler:
    def __init__(self, bot, bot_service):
        self.bot = bot
        self.bot_service = bot_service

    async def on_message(self, update):
        message: Message = update.message
        text = message.text or ""
        user_id = message.author.user_id
        peer = message.peer

        # –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        self.bot_service.log_message(user_id, text, message.message_id)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –±–æ—Ç–∞
        if not text.strip():
            return
        if not self._bot_mentioned(text):
            return

        question = self._strip_bot_mention(text)
        qa_pair = self.bot_service.get_best_answer(question)
        if qa_pair:
            answer_text = qa_pair.answer
        else:
            answer_text = "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ –∑–Ω–∞—é –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."

        interactive = InteractiveMediaGroup(
            medias=[
                InteractiveMedia(type="button", text="üëç", value="like"),
                InteractiveMedia(type="button", text="üëé", value="dislike"),
            ]
        )

        full_text = f"{answer_text}\n\n–ü–æ–Ω—Ä–∞–≤–∏–ª—Å—è –ª–∏ –æ—Ç–≤–µ—Ç?"

        await self.bot.messaging.send_message(peer, full_text, interactive_media_groups=[interactive])

    async def on_reaction(self, update):
        # –ó–¥–µ—Å—å update ‚Äî –æ–±—ä–µ–∫—Ç —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ä–µ–∞–∫—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ
        # –ù–∞–º –Ω—É–∂–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–∏–ø–µ —Ä–µ–∞–∫—Ü–∏–∏ (value), peer, user_id –∏ —Ç.–¥.
        reaction = update.reaction
        value = reaction.value  # "like" –∏–ª–∏ "dislike"
        user_id = update.user_id
        peer = update.peer

        if value == "dislike":
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º @sasha –≤ —á–∞—Ç
            text = "@sasha, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –¥–æ–≤–æ–ª–µ–Ω –æ—Ç–≤–µ—Ç–æ–º."
            await self.bot.messaging.send_message(peer, text)

    def _bot_mentioned(self, text: str) -> bool:
        return "@–±–æ—Ç" in text.lower()

    def _strip_bot_mention(self, text: str) -> str:
        return text.lower().replace("@–±–æ—Ç", "").strip()




12. data/knowledge.xlsx
question	answer
–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –±–æ—Ç?	–ë–æ—Ç –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã.
–ß—Ç–æ —Ç–∞–∫–æ–µ –°–±–µ—Ä—á–∞—Ç?	–°–±–µ—Ä—á–∞—Ç ‚Äî —ç—Ç–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞.
–ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è?	–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ.
–ö–∞–∫ –æ–±—É—á–∏—Ç—å –±–æ—Ç–∞?	–ü–æ–∫–∞ –æ–±—É—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –∞–¥–º–∏–Ω–æ–≤.
–ü—Ä–∏–≤–µ—Ç	–ü—Ä–∏–≤–µ—Ç! –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?

13. data/history.xlsx
user_id	text	message_id
123456	–ü—Ä–∏–≤–µ—Ç –±–æ—Ç	uuid-string-example





SBER_BOT_TOKEN = os.getenv("SBER_BOT_TOKEN", "demo_token")
KNOWLEDGE_BASE_PATH = "data/knowledge_base.xlsx"
CHAT_HISTORY_PATH = "data/chat_history.xlsx"
FEEDBACK_DATA_PATH = "data/feedback_data.xlsx"
ADMIN_CORRECTIONS_PATH = "data/admin_corrections.xlsx"
FULL_LOG_PATH = "data/full_chat_log.xlsx"
TAG_ADMIN = "@sasha"










3. domain/models/message.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from dataclasses import dataclass

@dataclass
class IncomingMessage:
    text: str
    user_id: int
    username: str
    message_id: str
üîπ –ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –ª—é–±–æ–µ –≤—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Å–∏—Å—Ç–µ–º–µ.

4. domain/models/answer.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from dataclasses import dataclass

@dataclass
class Answer:
    text: str
    question: str
5. domain/services/answer_selector.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from rapidfuzz import fuzz
from infrastructure.excel.knowledge_base import get_knowledge_data

def find_best_answer(user_question: str, threshold: int = 60):
    knowledge = get_knowledge_data()
    best_match = None
    highest_score = 0

    for entry in knowledge:
        score = fuzz.partial_ratio(user_question.lower(), entry['question'].lower())
        if score > highest_score and score >= threshold:
            highest_score = score
            best_match = entry

    return best_match
üîπ –õ–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞ –ª—É—á—à–µ–≥–æ –æ—Ç–≤–µ—Ç–∞ –ø–æ —á–∞—Å—Ç–∏—á–Ω–æ–º—É —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é.

6. application/handlers/message_handler.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from application.use_cases.process_user_message import handle_user_message
from dialog_bot_sdk.entities import Message

def process_message(message: Message):
    if not message.message or not message.message.text:
        return
    if '@bot' not in message.message.text:
        return

    handle_user_message(message)
üîπ –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∏ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏.

7. application/use_cases/process_user_message.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from infrastructure.excel.full_log import log_full_message
from infrastructure.excel.chat_history import log_chat
from infrastructure.sberchat.bot import send_reply
from domain.models.message import IncomingMessage
from domain.services.answer_selector import find_best_answer
from interface.interactive.buttons import get_feedback_buttons

def handle_user_message(message):
    user_message = message.message.text
    user_id = message.sender_uid
    username = str(message.sender_uid)  # –µ—Å–ª–∏ –Ω–µ—Ç –Ω–∏–∫–∞
    msg_id = str(message.message_id)

    log_full_message(message)

    matched = find_best_answer(user_message)
    if matched:
        send_reply(
            peer=message.peer,
            text=f"{matched['answer']}\n\n–ü–æ–Ω—Ä–∞–≤–∏–ª—Å—è –ª–∏ –æ—Ç–≤–µ—Ç?",
            reply_to=msg_id,
            buttons=get_feedback_buttons()
        )
        log_chat(user_message, matched['question'], matched['answer'], username)
    else:
        send_reply(peer=message.peer, text="–ù–µ –Ω–∞—à–µ–ª –æ—Ç–≤–µ—Ç. –Ø –∑–∞–ø–æ–º–Ω—é —ç—Ç–æ!", reply_to=msg_id)
8. application/use_cases/process_feedback.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from config.settings import TAG_ADMIN
from infrastructure.excel.feedback import log_feedback
from infrastructure.sberchat.bot import send_reply

def handle_feedback(message_id: str, user_id: int, value: str, original_question: str):
    log_feedback(message_id, user_id, value)

    if value == "dislike":
        send_reply(
            peer=...,  # –ø–æ–ª—É—á–∞–µ–º peer –∏–∑ context
            text=f"{TAG_ADMIN}, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ–¥–æ–≤–æ–ª–µ–Ω –æ—Ç–≤–µ—Ç–æ–º –Ω–∞: {original_question}"
        )
9. infrastructure/excel/*.py
–ü—Ä–∏–º–µ—Ä: knowledge_base.py

python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
import pandas as pd
from config.settings import KNOWLEDGE_BASE_PATH

def get_knowledge_data():
    df = pd.read_excel(KNOWLEDGE_BASE_PATH)
    return df.to_dict(orient="records")
–û—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã: chat_history.py, feedback.py, corrections.py, full_log.py ‚Äî —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ. –í—Å–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Å Pandas, –ø—Ä–æ—Å—Ç–æ —á–∏—Ç–∞—é—Ç –∏ –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç —Å—Ç—Ä–æ–∫–∏ –≤ –Ω—É–∂–Ω—ã–µ Excel-—Ñ–∞–π–ª—ã.

10. infrastructure/sberchat/bot.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from dialog_bot_sdk.bot import DialogBot
from dialog_bot_sdk.interactive_media import InteractiveMediaGroup, InteractiveMediaSelect
from config.settings import SBER_BOT_TOKEN
from application.handlers.message_handler import process_message

bot = None

def run_bot():
    global bot
    bot = DialogBot.get_secure_bot(SBER_BOT_TOKEN)
    bot.messaging.on_message(process_message)

def send_reply(peer, text, reply_to=None, buttons=None):
    from dialog_bot_sdk.entities import UUID
    uuid = UUID()
    group = InteractiveMediaGroup(
        [InteractiveMediaSelect("feedback", "like", "üëç"), InteractiveMediaSelect("feedback", "dislike", "üëé")]
    ) if buttons else None

    bot.messaging.reply(
        peer=peer,
        mids=[UUID(reply_to)] if reply_to else [],
        text=text,
        interactive_media_groups=[group] if group else None
    )
11. interface/interactive/buttons.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from dialog_bot_sdk.interactive_media import InteractiveMediaGroup, InteractiveMediaSelect

def get_feedback_buttons():
    return InteractiveMediaGroup([
        InteractiveMediaSelect("feedback", "like", "üëç"),
        InteractiveMediaSelect("feedback", "dislike", "üëé")
    ])










from dialog_bot_sdk.bot import DialogBot
from dialog_bot_sdk.config import BotConfig
from sberchat_bot.config import settings

def get_bot():
    return DialogBot.get_secure_bot(
        BotConfig(
            host=settings.SBER_API_ENDPOINT,
            token=settings.SBER_BOT_TOKEN
        )
    )
