1. main.py
python
Копировать
Редактировать
import logging
from config.config import BOT_ENDPOINT, BOT_TOKEN, BOT_NAME, SASHA_ID, logger
from infrastructure.sber_sdk import SberBot
from infrastructure.excel_repo import ExcelRepository
from domain.knowledge import KnowledgeBase
from domain.logic import BotLogic
from handlers.message_handler import register_handlers


def main():
    logger.info("Запуск бота...")

    # Инициализация репозиториев и бизнес-логики
    excel_repo = ExcelRepository()
    knowledge_base = KnowledgeBase()
    bot_logic = BotLogic(knowledge_base, excel_repo)

    # Создание экземпляра бота
    sber_bot = SberBot(BOT_ENDPOINT, BOT_TOKEN)

    # Регистрируем обработчики событий
    register_handlers(sber_bot, bot_logic, excel_repo)

    logger.info(f"Бот инициализирован (endpoint: {BOT_ENDPOINT}, bot_name: @{BOT_NAME})")

    try:
        sber_bot.start_polling()
    except Exception as e:
        logger.error(f"Ошибка при запуске бота: {e}", exc_info=True)


if __name__ == "__main__":
    main()
2. infrastructure/sber_sdk.py
python
Копировать
Редактировать
from dialog_bot_sdk.bot import DialogBot
from dialog_bot_sdk.entities.messaging import MessageHandler, CommandHandler, MessageContentType
from dialog_bot_sdk.utils import AsyncTask
import logging

logger = logging.getLogger(__name__)


class SberBot:
    def __init__(self, endpoint: str, token: str):
        # Создаём бота с безопасным соединением
        self.bot = DialogBot.create_bot({
            "endpoint": endpoint,
            "token": token,
            # Можно добавить "root_certificates" если надо
        })
        self.messaging = self.bot.messaging

    def on_message(self, func):
        self.messaging.message_handler([
            MessageHandler(func, MessageContentType.TEXT_MESSAGE)
        ])

    def on_command(self, command: str, description: str):
        def decorator(func):
            self.messaging.command_handler([
                CommandHandler(func, command, description=description)
            ])
            return func
        return decorator

    def send_message(self, peer, text: str, attachments=None):
        self.messaging.send_message(peer, text, attachments=attachments)

    def start_polling(self):
        self.bot.updates.on_updates(
            do_read_message=True,
            do_register_commands=True
        )
        self.bot.run()
3. infrastructure/excel_repo.py
python
Копировать
Редактировать
import os
import logging
from datetime import datetime
from openpyxl import Workbook, load_workbook

logger = logging.getLogger(__name__)


class ExcelRepository:
    def __init__(self):
        # Названия файлов
        self.knowledge_file = "knowledge_base.xlsx"
        self.chat_history_file = "chat_history.xlsx"
        self.feedback_file = "feedback_data.xlsx"
        self.full_log_file = "full_chat_log.xlsx"

        self._init_files()

    def _init_files(self):
        # Создаём и/или загружаем Excel-файлы с нужными листами и заголовками
        self._create_if_not_exists(self.knowledge_file, ["Question", "Answer"])
        self._create_if_not_exists(self.chat_history_file, ["User", "Message", "Timestamp"])
        self._create_if_not_exists(self.feedback_file, ["User", "Question", "Answer", "Feedback", "Timestamp"])
        self._create_if_not_exists(self.full_log_file, ["User", "Message", "Timestamp", "Source"])

    def _create_if_not_exists(self, filename: str, headers: list):
        if not os.path.exists(filename):
            logger.info(f"Создаём файл {filename}")
            wb = Workbook()
            ws = wb.active
            ws.append(headers)
            wb.save(filename)
            logger.info(f"Файл {filename} создан")

    def load_knowledge(self):
        # Загружаем базу знаний в виде списка словарей
        wb = load_workbook(self.knowledge_file)
        ws = wb.active
        knowledge = []
        for row in ws.iter_rows(min_row=2, values_only=True):
            if row[0] and row[1]:
                knowledge.append({"question": row[0], "answer": row[1]})
        logger.info(f"База знаний загружена, {len(knowledge)} записей")
        return knowledge

    def append_chat_history(self, user: str, message: str, timestamp: datetime):
        wb = load_workbook(self.chat_history_file)
        ws = wb.active
        ws.append([user, message, timestamp.isoformat()])
        wb.save(self.chat_history_file)

    def append_feedback(self, user: str, question: str, answer: str, feedback: str, timestamp: datetime):
        wb = load_workbook(self.feedback_file)
        ws = wb.active
        ws.append([user, question, answer, feedback, timestamp.isoformat()])
        wb.save(self.feedback_file)

    def append_full_log(self, user: str, message: str, timestamp: datetime, source: str):
        wb = load_workbook(self.full_log_file)
        ws = wb.active
        ws.append([user, message, timestamp.isoformat(), source])
        wb.save(self.full_log_file)
4. domain/knowledge.py
python
Копировать
Редактировать
import logging

logger = logging.getLogger(__name__)

class KnowledgeBase:
    def __init__(self):
        self.data = []

    def load(self, knowledge_data: list):
        self.data = knowledge_data
        logger.info(f"Загружено {len(self.data)} элементов базы знаний")

    def find_answer(self, question: str) -> str | None:
        # Очень простой поиск точного совпадения (можно заменить на что-то сложнее)
        question = question.lower()
        for entry in self.data:
            if entry["question"].lower() == question:
                return entry["answer"]
        return None
5. domain/logic.py
python
Копировать
Редактировать
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class BotLogic:
    def __init__(self, knowledge_base: KnowledgeBase, excel_repo):
        self.kb = knowledge_base
        self.repo = excel_repo

    def process_message(self, user: str, text: str) -> dict:
        """
        Обрабатывает сообщение пользователя:
        - записывает в лог
        - ищет ответ в базе знаний
        - возвращает результат с ответом и сообщением для отправки
        """
        self.repo.append_chat_history(user, text, datetime.now())
        answer = self.kb.find_answer(text)
        if answer:
            logger.info(f"Найден ответ для пользователя {user}")
            return {"reply": True, "answer": answer}
        else:
            logger.info(f"Ответ не найден для вопроса пользователя {user}")
            return {"reply": False, "answer": "Извините, я не знаю ответа на этот вопрос."}

    def process_feedback(self, user: str, question: str, answer: str, feedback: str) -> bool:
        """
        Обрабатывает отзыв (like/dislike):
        - сохраняет в файл
        - возвращает True, если нужно уведомить администратора (например, при dislike)
        """
        self.repo.append_feedback(user, question, answer, feedback, datetime.now())
        notify_admin = feedback.lower() == "dislike"
        logger.info(f"Обработка отзыва от пользователя {user}, notify_admin={notify_admin}")
        return notify_admin
6. handlers/message_handler.py
python
Копировать
Редактировать
import logging
from datetime import datetime
from config.config import BOT_NAME, SASHA_ID
from interface.keyboard import create_feedback_keyboard

logger = logging.getLogger(__name__)


def register_handlers(bot, bot_logic, excel_repo):
    @bot.on_message
    def handle_message(params):
        try:
            peer = params.peer
            message = params.message

            if not message.text_message:
                return
            text = message.text_message.text.strip()
            user = params.sender.uid

            # Логируем полное сообщение
            excel_repo.append_full_log(user, text, datetime.now(), "user")

            # Проверяем упоминание бота
            if f"@{BOT_NAME}" not in text.lower():
                return

            # Обработка сообщения
            result = bot_logic.process_message(user, text)

            if result["reply"]:
                bot.send_message(peer, result["answer"], attachments=create_feedback_keyboard())
        except Exception as e:
            logger.error(f"Ошибка при обработке сообщения: {e}", exc_info=True)


    @bot.on_message
    def handle_feedback(params):
        message = params.message
        if not message.text_message:
            return
        text = message.text_message.text.strip().lower()
        user = params.sender.uid
        peer = params.peer

        if text in ("like", "dislike"):
            # В реальном проекте тут нужно связывать отзыв с конкретным вопросом/ответом
            original_question = "Неизвестен"
            original_answer = "Неизвестен"

            mention_admin = bot_logic.process_feedback(user, original_question, original_answer, text)
            if mention_admin and SASHA_ID:
                notification = f"@{SASHA_ID} Пользователь {user} оставил отрицательный отзыв."
                bot.send_message(peer, notification)
            else:
                bot.send_message(peer, "Спасибо за ваш отзыв!")
7. interface/keyboard.py
python
Копировать
Редактировать
from dialog_bot_sdk.entities.messaging import InteractiveMedia, Button, ButtonType

def create_feedback_keyboard() -> InteractiveMedia:
    buttons = [
        Button(text="👍", type=ButtonType.TEXT, payload="like"),
        Button(text="👎", type=ButtonType.TEXT, payload="dislike"),
    ]
    return InteractiveMedia(buttons=buttons)
